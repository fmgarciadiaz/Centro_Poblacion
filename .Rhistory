.(export_value_fixed = sum(export_value_fixed, na.rm = TRUE)),
by = .(location_code, partner_code)]
# Armar todos los combos posibles
todos_los_nodos <- unique(rbindlist(list(MATRIZ_REDES[, c("location_code")], MATRIZ_REDES[, c("partner_code")]), use.names = FALSE))
MATRIZ_REDES <- MATRIZ_REDES[CJ(location_code=todos_los_nodos$location_code,              # completar anios ausentes
partner_code=todos_los_nodos$location_code), on=c('location_code','partner_code')][
order(location_code, partner_code)]
# Filtrar lo que no tiene coordinadas (i.e. que no es un pais)
MATRIZ_REDES <- MATRIZ_REDES[countries_data,
`:=`(location_name = country, location_region = region, location_flag = flag,
latitude = latitude, longitude = longitude),
on = .(location_code = iso3c)][countries_data,
`:=`(partner_name = country, partner_region = region),
on = .(partner_code = iso3c)][
!(is.na(location_name) | is.na(partner_name) | partner_code == "VIR" | location_code == "VIR"), ]
# borrar lo que esta abajo de treshold (asignarle weight cero, no borrar la fila, para que la matriz quede simetrica)
MATRIZ_REDES[, export_value_fixed := fcase(export_value_fixed > threshold, export_value_fixed,
export_value_fixed <= threshold, 0)]
# datos de los vertices (paises) // (casi todos, luego elijo solo los que figuran en MATRIZ_REDES)
MATRIZ_VERTEX_DATA <- ExpoMundo_RAW[year %in% anyo,
.(FOB2018 = sum(export_value_fixed[which(anyo == 2018)], na.rm = TRUE)),
by = .(location_code)][countries_data,
`:=`(location_name = country, location_region = region, location_flag = flag,
latitude = latitude, longitude = longitude),
on = .(location_code = iso3c)][
!(is.na(location_name)), ]
MATRIZ_VERTEX_DATA[which(location_code == "TWN"), `:=`(latitude = 25.0330, longitude = 121.5654)]
MATRIZ_VERTEX <- data.table(location_code = unique(MATRIZ_REDES$location_code))[MATRIZ_VERTEX_DATA, on = "location_code"]
rm(MATRIZ_VERTEX_DATA)
# Hacer matriz simetrica con los intercambios totales
MATRIZ_REDES <- dcast(MATRIZ_REDES, location_code  ~ partner_code, value.var = "export_value_fixed")
setnafill(MATRIZ_REDES, type = "const", fill = 0, cols = colnames(MATRIZ_REDES)[!colnames(MATRIZ_REDES) %in% "location_code"])
MATRIZ_REDES <- as.matrix(MATRIZ_REDES, rownames = "location_code")
MATRIZ_REDES <- (1/2) * MATRIZ_REDES + (1/2) * t(MATRIZ_REDES) # simetrica
# Armar top 3 socios comerciales (considerando X + M)
TOP_SOCIOS   <- MATRIZ_REDES %>%  as.data.table(keep.rownames = "location_code") %>%
melt(id.vars = "location_code", variable.name = "partner_code", value.name = "export_value_fixed") %>%
.[order(-export_value_fixed),
.(top3_socios = paste(partner_code[1:4], collapse = " "),
USA_rank = seq_len(.N)[which(partner_code=="USA")],
DEU_rank = seq_len(.N)[which(partner_code=="DEU")],
CHN_rank = seq_len(.N)[which(partner_code=="CHN")],
JPN_rank = seq_len(.N)[which(partner_code=="JPN")],
ZAF_rank = seq_len(.N)[which(partner_code=="ZAF")]),
by = .(location_code)]
TOP_SOCIOS[countries_data, region := i.region, on = .(location_code = iso3c)]                           # Armar top 3 socios por pais
TOP_SOCIOS_REGION <- TOP_SOCIOS[!location_code %in% c("USA","CHN","DEU","JPN","ZAF"),
.(USA_rank = round(mean(USA_rank, na.rm = TRUE),1),
DEU_rank = round(mean(DEU_rank, na.rm = TRUE),1),
CHN_rank = round(mean(CHN_rank, na.rm = TRUE),1),
JPN_rank = round(mean(JPN_rank, na.rm = TRUE),1),
ZAF_rank = round(mean(ZAF_rank, na.rm = TRUE),1)),
by = region]
## 6.B Armar el grafo con suma de X + M como weight ----
## Y luego armar comunidades y centralidad
WorldGraph   <- graph_from_adjacency_matrix(MATRIZ_REDES, mode = "upper",       # es undirected asi que es lo mismo
weighted = "export_value_fixed") %>% as_tbl_graph()
WorldGraph   <- WorldGraph %>% activate(nodes) %>% left_join(MATRIZ_VERTEX, by = c("name" = "location_code")) # sumar datos de nodos
# Armar comunidades de comercio y centralidad
WorldGraph   <- WorldGraph %>% activate(nodes) %>% filter(!node_is_isolated(), !is.na(longitude)) %>% # borrar los que no tienen dato
mutate(group = factor(group_louvain(weights = export_value_fixed)),
centrality = centrality_betweenness(weights =
max(export_value_fixed)/export_value_fixed, directed = FALSE)) %>%
ungroup() %>% group_by(group) %>% mutate(group_name = location_name[which.max(centrality)])
## 6.C Preparar chart ----
## Voy a hacer el plot con ggplot plain, para eso debo obtener todas las trayectorias
WorldGraph_df <- igraph::as_long_data_frame(WorldGraph)
# Version con curvas bezier (great circles queda fea)
WorldGraph_df  <- WorldGraph_df %>% rowwise() %>% mutate(geometry =
st_sfc(st_linestring(as.matrix(bezier.uv.arc( c(from_longitude, from_latitude),
c(to_longitude,to_latitude), n = 20))), crs = st_crs(4326)))
source("Utils.R")
# Version con curvas bezier (great circles queda fea)
WorldGraph_df  <- WorldGraph_df %>% rowwise() %>% mutate(geometry =
st_sfc(st_linestring(as.matrix(bezier.uv.arc( c(from_longitude, from_latitude),
c(to_longitude,to_latitude), n = 20))), crs = st_crs(4326)))
# Arco bezier
bezier.uv.arc <- function(p1, p2, n = 20) {
# Get unit vector from P1 to P2
u <- p2 - p1
u <- u / sqrt(sum(u*u))
d <- sqrt(sum((p1-p2)^2))
# Calculate third point for spline
m <- d / 2
h <- floor(d * .2)
# Create new points in rotated space
pp1 <- c(0,0)
pp2 <- c(d,0)
pp3 <- c(m, h)
mx <- as.matrix(bezier.curve(pp1, pp2, pp3, n))
# Now translate back to original coordinate space
theta <- acos(sum(u * c(1,0))) * sign(u[2])
ct <- cos(theta)
st <- sin(theta)
tr <- matrix(c(ct,  -1 * st, st, ct),ncol=2)
tt <- matrix(rep(p1,nrow(mx)),ncol=2,byrow=TRUE)
points <- tt + (mx %*% tr)
tmp.df <- data.frame(points)
colnames(tmp.df) <- c("lon","lat")
tmp.df
}
source("~/Dropbox/Trabajo/CEPAL Reloaded/1 CES/2 EconomiaComplejidad2021/Utils.R")
# Version con curvas bezier (great circles queda fea)
WorldGraph_df  <- WorldGraph_df %>% rowwise() %>% mutate(geometry =
st_sfc(st_linestring(as.matrix(bezier.uv.arc( c(from_longitude, from_latitude),
c(to_longitude,to_latitude), n = 20))), crs = st_crs(4326)))
source("~/Dropbox/Trabajo/CEPAL Reloaded/1 CES/2 EconomiaComplejidad2021/CES2021 - Modulo Hardvard y Complexity-con2019.R")
source("Utils.R")
source("~/Dropbox/Trabajo/CEPAL Reloaded/1 CES/2 EconomiaComplejidad2021/Utils.R")
source("~/Dropbox/Trabajo/CEPAL Reloaded/1 CES/3 InsercionExportadora/0 Aspectos Globales.R")
library(hrbrthemes)
library(raster)
library(ggspatial)
library(ggplot2)
library(viridis)
library(sf)
library(dplyr)
library(svglite)
source("Utils.R")
# 0 Definiciones
"%+%" <- function(x,y) paste(x,y,sep="") # se define %+% como concatenacion
data_dir       <- getwd()%+%"/data/"
results_dir    <- getwd()%+%"/results/"
gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "ppp_2020_10km_Aggregated.tif")
library(hrbrthemes)
library(raster)
library(ggspatial)
library(ggplot2)
library(viridis)
library(sf)
library(dplyr)
library(svglite)
source("Utils.R")
# 0 Definiciones
"%+%" <- function(x,y) paste(x,y,sep="") # se define %+% como concatenacion
data_dir       <- getwd()%+%"/data/"
results_dir    <- getwd()%+%"/results/"
gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "ppp_2020_10km_Aggregated.tif")
#gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
gis_dir        <- "/Volumes/MacDisk/Bases/GIS/WorldPopulation"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "ppp_2020_10km_Aggregated.tif")
library(hrbrthemes)
library(raster)
library(ggspatial)
library(ggplot2)
library(viridis)
library(sf)
library(dplyr)
library(svglite)
source("Utils.R")
# 0 Definiciones
"%+%" <- function(x,y) paste(x,y,sep="") # se define %+% como concatenacion
data_dir       <- getwd()%+%"/data/"
results_dir    <- getwd()%+%"/results/"
#gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
gis_dir        <- "/Volumes/MacDisk/Bases/GIS/WorldPopulation"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "ppp_2020_10km_Aggregated.tif")
#gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
gis_dir        <- "/Volumes/MacDisk/Bases/GIS/WorldPopulation/"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "ppp_2020_10km_Aggregated.tif")
#gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
gis_dir        <- "/Volumes/MacDisk/Bases/GIS/WorldPopulation/"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "ppp_2020_10km_Aggregated.tif")
install.packages("rgdal")
library(hrbrthemes)
library(raster)
library(ggspatial)
library(ggplot2)
library(viridis)
library(sf)
library(dplyr)
library(svglite)
source("Utils.R")
# 0 Definiciones
"%+%" <- function(x,y) paste(x,y,sep="") # se define %+% como concatenacion
data_dir       <- getwd()%+%"/data/"
results_dir    <- getwd()%+%"/results/"
#gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
gis_dir        <- "/Volumes/MacDisk/Bases/GIS/WorldPopulation/"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "ppp_2020_10km_Aggregated.tif")
PROY <- "+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs" # Proyeccion Seleccionada para MAPAS ROBINSON
#Population     <- aggregate(Population, fact = 20, fun = sum, na.rm = TRUE) #reducir precision
Population.df  <- as.data.frame(aggregate(Population, fact = 30,
fun = sum, na.rm = TRUE), xy = TRUE) # Pasar a data.frame para hacer el analisis, reduciendo detalle
Population     <- projectRaster(Population, crs = (PROY) , over = TRUE) # cambiar la proyeccion
# Vectores
graticula      <- st_read(dsn="/Volumes/SanDiskFGD/Bases/GIS/natural_earth_vector/110m_physical", layer="ne_110m_graticules_15")
bounding       <- st_read(dsn="/Volumes/SanDiskFGD/Bases/GIS/natural_earth_vector/110m_physical", layer="ne_110m_wgs84_bounding_box")
ocean          <- st_read(dsn="/Volumes/SanDiskFGD/Bases/GIS/natural_earth_vector/110m_physical", layer="ne_110m_ocean")
wmap_countries <- st_read(dsn="/Volumes/SanDiskFGD/Bases/GIS/natural_earth_vector/110m_cultural", layer="ne_110m_admin_0_countries") # cargar mapa del mundo/110m_cultural", layer="ne_110m_admin_0_countries") # cargar mapa del mundo
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "WorldPopulation/" %+% "ppp_2020_10km_Aggregated.tif")
#gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
gis_dir        <- "/Volumes/MacDisk/Bases/GIS/"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "WorldPopulation/" %+% "ppp_2020_10km_Aggregated.tif")
PROY <- "+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs" # Proyeccion Seleccionada para MAPAS ROBINSON
#Population     <- aggregate(Population, fact = 20, fun = sum, na.rm = TRUE) #reducir precision
Population.df  <- as.data.frame(aggregate(Population, fact = 30,
fun = sum, na.rm = TRUE), xy = TRUE) # Pasar a data.frame para hacer el analisis, reduciendo detalle
Population     <- projectRaster(Population, crs = (PROY) , over = TRUE) # cambiar la proyeccion
# Vectores
graticula      <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_physical", layer="ne_110m_graticules_15")
bounding       <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_physical", layer="ne_110m_wgs84_bounding_box")
ocean          <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_physical", layer="ne_110m_ocean")
wmap_countries <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_cultural", layer="ne_110m_admin_0_countries") # cargar mapa del mundo/110m_cultural", layer="ne_110m_admin_0_countries") # cargar mapa del mundo
#graticula      <- st_transform(graticula, PROY)
#bounding       <- st_transform(bounding,   PROY)
#ocean          <- st_transform(ocean, PROY)
#wmap_countries <- st_transform(wmap_countries, PROY) # proyeccion Robin
# Centroides
centroides <- st_centroid(wmap_countries)
library(hrbrthemes)
library(raster)
library(ggspatial)
library(ggplot2)
library(viridis)
library(sf)
library(dplyr)
library(svglite)
source("Utils.R")
# 0 Definiciones
"%+%" <- function(x,y) paste(x,y,sep="") # se define %+% como concatenacion
data_dir       <- getwd()%+%"/data/"
results_dir    <- getwd()%+%"/results/"
#gis_dir        <- "/Volumes/SanDiskFGD/Bases/GIS/WorldPopulation/"
gis_dir        <- "/Volumes/MacDisk/Bases/GIS/"
# 1 Load Data
#Population     <- raster(gis_dir %+% "ppp_2020_1km_Aggregated.tif") # version original que comprimi
#Population     <- aggregate(Population, fact = 10, fun = sum, na.rm = TRUE) # reducir precision
#writeRaster(Population, filename = gis_dir %+% "ppp_2020_10km_Aggregated.tif", overwrite = TRUE)
Population     <- raster(gis_dir %+% "WorldPopulation/" %+% "ppp_2020_10km_Aggregated.tif")
PROY <- "+proj=robin +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +datum=WGS84 +units=m +no_defs" # Proyeccion Seleccionada para MAPAS ROBINSON
#Population     <- aggregate(Population, fact = 20, fun = sum, na.rm = TRUE) #reducir precision
Population.df  <- as.data.frame(aggregate(Population, fact = 30,
fun = sum, na.rm = TRUE), xy = TRUE) # Pasar a data.frame para hacer el analisis, reduciendo detalle
Population     <- projectRaster(Population, crs = (PROY) , over = TRUE) # cambiar la proyeccion
# Vectores
graticula      <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_physical", layer="ne_110m_graticules_15")
bounding       <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_physical", layer="ne_110m_wgs84_bounding_box")
ocean          <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_physical", layer="ne_110m_ocean")
wmap_countries <- st_read(dsn=gis_dir %+% "natural_earth_vector/110m_cultural", layer="ne_110m_admin_0_countries") # cargar mapa del mundo/110m_cultural", layer="ne_110m_admin_0_countries") # cargar mapa del mundo
#graticula      <- st_transform(graticula, PROY)
#bounding       <- st_transform(bounding,   PROY)
#ocean          <- st_transform(ocean, PROY)
#wmap_countries <- st_transform(wmap_countries, PROY) # proyeccion Robin
# Centroides
centroides <- st_centroid(wmap_countries)
# 2 World Population Plot
test           <- catenaria(GetCoords("AR"),GetCoords("CN"), PROY, PROY) %>% data.frame()
ggplot() +
geom_sf(data = wmap_countries, fill = "gray", color ="white", size=0.2, alpha= 1) +  # ideal para indices
layer_spatial(Population,  aes(fill = stat(band1)), alpha = 0.8) +
geom_sf(data = ocean, fill ="darkgray", color = "black", alpha = 1, size = 0.1) +
geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_fill_viridis(limits = c(0,100000), na.value = NA, "Densidad") +
#geom_path(data = test, aes(lon, lat, group = part), color ="white", size= 0.5, alpha= 0.6,
#          arrow = arrow(type = "open", angle = 30, length = unit(0.1, "inches"))) +  # ideal para indices
#coord_sf(ylim = c(-50, 90)) +
theme_ipsum() +
labs(title = "Población mundial", caption = "Fuente: F.García Díaz")
# 3 Geo-Analisis
# Para cada punto del mapa, armar la distancia media de cada persona a ese punto
Population.distance <- matrix(ncol = 1, nrow = length(Population.df$ppp_2020_10km_Aggregated))
pb = txtProgressBar(min = 0, max = length(Population.df$ppp_2020_10km_Aggregated), initial = 0, style = 3)
for (i in 1:length(Population.df$ppp_2020_10km_Aggregated)){
setTxtProgressBar(pb,i)
Population.df$distances  <- distGeo( Population.df[, 1:2], Population.df[i, 1:2]  )/1000
Population.df$weighted   <- Population.df$distances * Population.df$ppp_2020_10km_Aggregated
Population.distance[i] <- sum(Population.df$weighted, na.rm = TRUE)/sum(Population.df$ppp_2020_10km_Aggregated, na.rm = TRUE)
}
Population.distance   <- as.data.frame(Population.distance)
Population.distance$x <- Population.df$x
Population.distance$y <- Population.df$y
# buscar el "centro de masa"
centro <- Population.distance[which(Population.distance$V1 == min(Population.distance$V1, na.rm = TRUE)),2:3]
# Transformar en raster layer
coordinates(Population.distance) <- ~ x + y
gridded(Population.distance) <- TRUE
# coerce to raster
Population.distance   <- raster(Population.distance)
crs(Population.distance) <- "+proj=longlat +datum=WGS84 +no_defs"
shading      <- ggplot() +
#geom_sf(data = wmap_countries, fill = "gray", color ="white", size=0.2, alpha= 1) +  # ideal para indices
layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.7) +
scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90))
shading.Grob <- ggplotGrob(shading)
# graficar
g <- ggplot() +
geom_sf(data = wmap_countries, fill = "white", color ="black", size = 0.1, alpha = 1) +  # ideal para indices
annotation_custom(grob = shading.Grob$grobs[[6]]$children[[3]]) +
#layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.8) +
layer_spatial(data = Population,  aes(alpha = stat(band1)), fill = "black") +
geom_sf(data = ocean, fill ="#f5f5f2", color = "#f5f5f2", alpha = 1, size = 1) +
geom_sf(data = wmap_countries, fill = NA, color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_alpha_continuous(limits = c(0, 300000), na.value = 0) +
geom_spatial_point(data = centro, aes(x,y)) +
#scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90)) +
theme_map() + theme(legend.position = "none") +
labs(title = "Distribución global de la población",
subtitle = "Distancia media a cada ser humano", caption = "Fuente: F.García Díaz en base a WorldPop")
g
# 2 World Population Plot
test           <- catenaria(GetCoords("AR"),GetCoords("CN"), PROY, PROY) %>% data.frame()
centroides <- st_centroid(wmap_countries)
View(Population.distance)
View(wmap_countries)
View(Population.distance)
shading
plot_distance = aggregate(Population.distance, wmap_countries, mean, as_points = FALSE)
plot_distance = aggregate(Population.distance, wmap_countries$geometry, mean, as_points = FALSE)
Population.distance
wmap_countries
crs(wmap_countries)
# 3 Geo-Analisis
# Para cada punto del mapa, armar la distancia media de cada persona a ese punto
Population.distance <- matrix(ncol = 1, nrow = length(Population.df$ppp_2020_10km_Aggregated))
pb = txtProgressBar(min = 0, max = length(Population.df$ppp_2020_10km_Aggregated), initial = 0, style = 3)
for (i in 1:length(Population.df$ppp_2020_10km_Aggregated)){
setTxtProgressBar(pb,i)
Population.df$distances  <- distGeo( Population.df[, 1:2], Population.df[i, 1:2]  )/1000
Population.df$weighted   <- Population.df$distances * Population.df$ppp_2020_10km_Aggregated
Population.distance[i] <- sum(Population.df$weighted, na.rm = TRUE)/sum(Population.df$ppp_2020_10km_Aggregated, na.rm = TRUE)
}
Population.distance   <- as.data.frame(Population.distance)
Population.distance$x <- Population.df$x
Population.distance$y <- Population.df$y
# buscar el "centro de masa"
centro <- Population.distance[which(Population.distance$V1 == min(Population.distance$V1, na.rm = TRUE)),2:3]
# Transformar en raster layer
coordinates(Population.distance) <- ~ x + y
gridded(Population.distance) <- TRUE
# coerce to raster
Population.distance   <- raster(Population.distance)
crs(Population.distance) <- crs(wmap_countries)
shading      <- ggplot() +
#geom_sf(data = wmap_countries, fill = "gray", color ="white", size=0.2, alpha= 1) +  # ideal para indices
layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.7) +
scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90))
shading.Grob <- ggplotGrob(shading)
shading
# graficar
g <- ggplot() +
geom_sf(data = wmap_countries, fill = "white", color ="black", size = 0.1, alpha = 1) +  # ideal para indices
annotation_custom(grob = shading.Grob$grobs[[6]]$children[[3]]) +
#layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.8) +
layer_spatial(data = Population,  aes(alpha = stat(band1)), fill = "black") +
geom_sf(data = ocean, fill ="#f5f5f2", color = "#f5f5f2", alpha = 1, size = 1) +
geom_sf(data = wmap_countries, fill = NA, color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_alpha_continuous(limits = c(0, 300000), na.value = 0) +
geom_spatial_point(data = centro, aes(x,y)) +
#scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90)) +
theme_map() + theme(legend.position = "none") +
labs(title = "Distribución global de la población",
subtitle = "Distancia media a cada ser humano", caption = "Fuente: F.García Díaz en base a WorldPop")
g
plot_distance = aggregate(Population.distance, wmap_countries$geometry, mean, as_points = FALSE)
plot_distance = aggregate(Population.distance, wmap_countries, fun = "mean")
filter(wmap_countries, REGION_WB == "Latin America & Caribbean")
filter(wmap_countries, REGION_WB == "Latin America & Caribbean")
plot_distance = aggregate(Population.distance, filter(wmap_countries, REGION_WB == "Latin America & Caribbean"), fun = "mean")
install.packages("exactextractr")
install.packages("exactextractr")
library(exactextractr)
install.packages("exactextractr")
install.packages("exactextractr")
library(exactextractr)
exact_extract(Population.distance, brazil, 'mean')
exact_extract(Population.distance, wmap_countries, 'mean')
# Obtener las distancias medias
wmap_countries <- wmap_countries |> mutate(distancia_media = exact_extract(Population.distance, wmap_countries, 'mean'))
# graficar
g <- ggplot() +
geom_sf(data = wmap_countries, aes(fill = distancia_media), color ="black", size = 0.1, alpha = 1) +  # ideal para indices
annotation_custom(grob = shading.Grob$grobs[[6]]$children[[3]]) +
#layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.8) +
#      layer_spatial(data = Population,  aes(alpha = stat(band1)), fill = "black") +
scale_fill_viridis_c(option = "magma", direction = -1) +
geom_sf(data = ocean, fill ="#f5f5f2", color = "#f5f5f2", alpha = 1, size = 1) +
geom_sf(data = wmap_countries, fill = NA, color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_alpha_continuous(limits = c(0, 300000), na.value = 0) +
geom_spatial_point(data = centro, aes(x,y)) +
#scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90)) +
theme_map() + theme(legend.position = "none") +
labs(title = "Distribución global de la población",
subtitle = "Distancia media a cada ser humano", caption = "Fuente: F.García Díaz en base a WorldPop")
g
# graficar
g <- ggplot() +
geom_sf(data = wmap_countries, aes(fill = distancia_media), color ="black", size = 0.1, alpha = 1) +  # ideal para indices
annotation_custom(grob = shading.Grob$grobs[[6]]$children[[3]]) +
#layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.8) +
#      layer_spatial(data = Population,  aes(alpha = stat(band1)), fill = "black") +
scale_fill_viridis_c(option = "magma", direction = -1) +
geom_sf(data = ocean, fill ="#f5f5f2", color = "#f5f5f2", alpha = 1, size = 1) +
geom_sf(data = wmap_countries, fill = NA, color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_alpha_continuous(limits = c(0, 300000), na.value = 0) +
geom_spatial_point(data = centro, aes(x,y)) +
#scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90)) +
theme_map() + theme(legend.position = "none") +
labs(title = "Distribución global de la población",
subtitle = "Distancia media a cada ser humano", caption = "Fuente: F.García Díaz en base a WorldPop")
g
# graficar
g <- ggplot() +
geom_sf(data = wmap_countries, aes(fill = distancia_media), color ="black", size = 0.1, alpha = 1) +  # ideal para indices
#      annotation_custom(grob = shading.Grob$grobs[[6]]$children[[3]]) +
#layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.8) +
#      layer_spatial(data = Population,  aes(alpha = stat(band1)), fill = "black") +
scale_fill_viridis_c(option = "magma", direction = -1) +
geom_sf(data = ocean, fill ="#f5f5f2", color = "#f5f5f2", alpha = 1, size = 1) +
geom_sf(data = wmap_countries, fill = NA, color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_alpha_continuous(limits = c(0, 300000), na.value = 0) +
geom_spatial_point(data = centro, aes(x,y)) +
#scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90)) +
theme_map() + theme(legend.position = "none") +
labs(title = "Distribución global de la población",
subtitle = "Distancia media a cada ser humano", caption = "Fuente: F.García Díaz en base a WorldPop")
g
g
# graficar
g <- ggplot() +
geom_sf(data = wmap_countries, aes(fill = distancia_media), color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#      annotation_custom(grob = shading.Grob$grobs[[6]]$children[[3]]) +
#layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.8) +
#      layer_spatial(data = Population,  aes(alpha = stat(band1)), fill = "black") +
scale_fill_viridis_c(option = "magma", direction = -1) +
geom_sf(data = ocean, fill ="#f5f5f2", color = "#f5f5f2", alpha = 1, size = 1) +
geom_sf(data = wmap_countries, fill = NA, color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_alpha_continuous(limits = c(0, 300000), na.value = 0) +
geom_spatial_point(data = centro, aes(x,y)) +
#scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90)) +
theme_map() + theme(legend.position = "none") +
labs(title = "Distribución global de la población",
subtitle = "Distancia media a cada ser humano", caption = "Fuente: F.García Díaz en base a WorldPop")
g
# graficar
g <- ggplot() +
geom_sf(data = wmap_countries, aes(fill = distancia_media), color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#      annotation_custom(grob = shading.Grob$grobs[[6]]$children[[3]]) +
#layer_spatial(data = Population.distance,  aes(fill = stat(band1)), alpha = 0.8) +
#      layer_spatial(data = Population,  aes(alpha = stat(band1)), fill = "black") +
scale_fill_viridis_c(option = "magma", direction = -1) +
geom_sf(data = ocean, fill ="#f5f5f2", color = "#f5f5f2", alpha = 1, size = 1) +
geom_sf(data = wmap_countries, fill = NA, color ="#f5f5f2", size = 0.1, alpha = 1) +  # ideal para indices
#geom_sf(data = graticula, color = "black", alpha = 1, size = 0.1) +
scale_alpha_continuous(limits = c(0, 300000), na.value = 0) +
geom_spatial_point(data = centro, aes(x,y)) +
#scale_fill_viridis_c(option = "magma", direction = -1) +
coord_sf(ylim = c(-50, 90)) +
theme_map() + theme(legend.position = "none") +
labs(title = "Distribución global de la población",
subtitle = "Distancia media a cada ser humano", caption = "Fuente: F.García Díaz en base a WorldPop") +
theme(plot.title = element_text(face = "bold"))
g
svglite(results_dir %+% "Distribucion Poblacion-discreto.svg" , pointsize = 11 , width = 11 , height = 6.89)
g
dev.off()
source("~/Library/CloudStorage/OneDrive-UnitedNations/Trabajo/1 CES/3 InsercionExportadora/Aspectos Globales Autocontenido.R")
version
usethis::use_git()
usethis::git_sitrep()
